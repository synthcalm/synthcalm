<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mood Into Art</title>
  <link rel="stylesheet" href="/synthcalm/style.css"/>
  <style>
    #startVoice.recording {
      border-color: magenta;
      color: magenta;
    }
    
    .image-frame {
      margin: 20px 0;
      min-height: 200px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #generatedImage {
      max-width: 100%;
      max-height: 500px;
      border: 1px solid #0ff;
      display: none;
    }
    
    #thinking {
      padding: 10px;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0% { opacity: 0.2; }
      50% { opacity: 1; }
      100% { opacity: 0.2; }
    }
  </style>
</head>
<body>
  <div class="container">
    <p>1. Press the "Start Voice" button and say what you feel. You have 60 Seconds. 2. Choose an art style. 3. Generate Image.</p>

    <canvas id="waveform"></canvas>

    <div class="footer-bar">
      <div id="dateTimeDisplay" class="seven-segment"></div>
      <div id="countdownDisplay" class="seven-segment">00:60</div>
    </div>

    <textarea id="activityInput" rows="4" placeholder="Describe your mood... (editable after recording)"></textarea>

    <div class="button-group">
      <button class="button" id="startVoice">Start Voice</button>
      <button class="button" id="clear">Clear</button>
      <select id="styleSelect">
        <option value="none" selected disabled>Choose Style</option>
        <option value="photo">Hyper-realistic Photo</option>
        <option value="anime">Japanese Anime Style</option>
        <option value="abstract">Abstract</option>
        <option value="surrealism">Surrealism</option>
        <option value="post-modern">Post-modern</option>
        <option value="cyberpunk">Cyberpunk</option>
        <option value="arabic-calligraphy">Arabic Calligraphy</option>
        <option value="chinese-calligraphy">Chinese Calligraphy</option>
        <option value="japanese-calligraphy">Japanese Calligraphy</option>
        <option value="marvel">Marvel Comic</option>
        <option value="art-deco">Art Deco</option>
        <option value="impressionist">Impressionist</option>
        <option value="pop-art">Pop Art</option>
        <option value="digital-painting">Digital Painting</option>
        <option value="minimalism">Minimalism</option>
      </select>
      <button class="button" id="generate">Generate Image</button>
      <button class="button" id="saveMood">Save</button>
      <button class="button" onclick="window.location.href='https://synthcalm.com'">Return to SynthCalm</button>
    </div>

    <hr style="border: none; border-top: 1px solid #0ff; margin: 20px 0;" />
    <p style="color:#0ff;font-size:14px;text-align:center;">Mood History</p>

    <div class="image-frame">
      <img id="generatedImage" alt="Generated mood art" />
    </div>

    <div id="thinking" style="display:none;text-align:center;color:#ff0;font-family:'Courier New', monospace;">Generating...</div>

    <div id="moodHistory" style="min-height: 100px;"></div>
  </div>

  <script>
    // Fix Local Time Display
    function updateDateTime() {
      const now = new Date();
      const options = {
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        hour12: false,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      };
      const formatted = new Intl.DateTimeFormat('default', options).format(now);
      document.getElementById('dateTimeDisplay').textContent = formatted;
    }
    setInterval(updateDateTime, 1000);
    updateDateTime();
    
    // Voice Recording Functionality
    const startVoiceBtn = document.getElementById("startVoice");
    const countdownDisplay = document.getElementById("countdownDisplay");
    const activityInput = document.getElementById("activityInput");
    let mediaRecorder;
    let audioChunks = [];
    let countdownInterval;
    let secondsLeft = 60;
    
    startVoiceBtn.addEventListener("click", toggleRecording);
    
    async function toggleRecording() {
      if (startVoiceBtn.classList.contains("recording")) {
        // Stop recording
        stopRecording();
      } else {
        // Start recording
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          startRecordingWithStream(stream);
        } catch (err) {
          console.error("Error accessing microphone:", err);
          alert("Could not access your microphone. Please check permissions.");
        }
      }
    }
    
    function startRecordingWithStream(stream) {
      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];
      
      mediaRecorder.addEventListener("dataavailable", event => {
        audioChunks.push(event.data);
      });
      
      mediaRecorder.addEventListener("stop", processAudio);
      
      // Reset and start countdown
      secondsLeft = 60;
      updateCountdown();
      countdownInterval = setInterval(() => {
        secondsLeft--;
        updateCountdown();
        
        if (secondsLeft <= 0) {
          stopRecording();
        }
      }, 1000);
      
      // Start recording
      mediaRecorder.start();
      startVoiceBtn.classList.add("recording");
      startVoiceBtn.textContent = "Stop Recording";
      
      // Clear previous input
      activityInput.value = "";
    }
    
    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
      }
      
      clearInterval(countdownInterval);
      startVoiceBtn.classList.remove("recording");
      startVoiceBtn.textContent = "Start Voice";
    }
    
    function updateCountdown() {
      const minutes = Math.floor(secondsLeft / 60);
      const seconds = secondsLeft % 60;
      countdownDisplay.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
    }
    
    async function processAudio() {
      const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
      
      try {
        // For now just simulate speech-to-text with a delay
        // In a real app, send this to a speech recognition API
        await new Promise(resolve => setTimeout(resolve, 1000));
        activityInput.value = "I feel " + ["happy", "calm", "excited", "reflective", "creative"][Math.floor(Math.random() * 5)] + " today.";
      } catch (err) {
        console.error("Error processing audio:", err);
        alert("Failed to process audio.");
      }
    }
    
    // Save Mood Functionality
    document.getElementById("saveMood").addEventListener("click", () => {
      const mood = activityInput.value.trim();
      const style = document.getElementById("styleSelect").value;
      const imageEl = document.getElementById("generatedImage");
      
      if (!mood) {
        alert("Please enter your mood before saving.");
        return;
      }
      
      const timestamp = new Date().toLocaleString();
      const imageSrc = imageEl.style.display !== "none" ? imageEl.src : "";
      
      // Create mood history entry
      const historyEntry = document.createElement("div");
      historyEntry.classList.add("mood-entry");
      historyEntry.innerHTML = `
        <p><strong>${timestamp}</strong>: ${mood}</p>
        ${imageSrc ? `<img src="${imageSrc}" alt="Mood art" style="max-width:200px;max-height:150px;">` : ''}
        <hr>
      `;
      
      document.getElementById("moodHistory").prepend(historyEntry);
      
      // In a real app, you would save this to localStorage or a database
      console.log("Saved mood:", { timestamp, mood, style, imageSrc });
    });

    // Image Generation with Stability API
    document.getElementById("generate").addEventListener("click", async () => {
      const mood = document.getElementById("activityInput").value;
      const style = document.getElementById("styleSelect").value;
      const thinking = document.getElementById("thinking");
      const imageEl = document.getElementById("generatedImage");

      if (!mood || style === "none") {
        alert("Please enter your mood and select a style.");
        return;
      }

      thinking.style.display = "block";
      imageEl.style.display = "none";

      try {
        // Create a prompt that combines the mood and style
        const prompt = `Create an image based on the mood: "${mood}" in ${style} style.`;
        
        // Make API request to Stability AI
        const response = await fetch('https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/text-to-image', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': 'Bearer ' + process.env.STABILITY_API_KEY // This should be set in your environment
          },
          body: JSON.stringify({
            text_prompts: [
              {
                text: prompt,
                weight: 1
              }
            ],
            cfg_scale: 7,
            height: 1024,
            width: 1024,
            samples: 1,
            steps: 30
          })
        });

        if (!response.ok) {
          throw new Error(`Stability API error: ${response.status} ${response.statusText}`);
        }

        const responseData = await response.json();
        
        if (responseData.artifacts && responseData.artifacts.length > 0) {
          const base64Image = responseData.artifacts[0].base64;
          imageEl.src = `data:image/png;base64,${base64Image}`;
          imageEl.style.display = "block";
        } else {
          throw new Error("No image generated");
        }
      } catch (err) {
        console.error("Image generation error:", err);
        alert("Failed to generate image. Error: " + err.message);
        
        // Fallback for testing/development
        console.log("Using fallback image for testing");
        imageEl.src = "/api/placeholder/500/500"; // Placeholder image as fallback
        imageEl.style.display = "block";
      } finally {
        thinking.style.display = "none";
      }
    });

    // Clear Button Functionality
    document.getElementById("clear").addEventListener("click", () => {
      document.getElementById("activityInput").value = "";
      document.getElementById("styleSelect").value = "none";
      document.getElementById("generatedImage").style.display = "none";
    });
  </script>
</body>
</html>
