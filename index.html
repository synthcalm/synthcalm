<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Mood Into Art</title>
    <link rel="stylesheet" href="/synthcalm/style.css"/>
    <style>
        #startVoice.recording {
            border-color: magenta;
            color: magenta;
        }

        #clear.active,
        #styleSelect.active,
        #generate.active,
        #saveMood.active,
        #synthCalmHome.active {
            border-color: yellow;
        }

        #generate.active {
            background-color: yellow;
            color: black;
        }

        #styleSelect:focus {
            outline: 2px solid yellow;
        }
    </style>
</head>
<body>
<div class="container">
    <p>1. Press the "Start Voice" button and say what you feel. You have 60 Seconds. 2. Choose an art style. 3. Generate Image.</p>

    <canvas id="waveform" aria-label="Waveform Visualization"></canvas>

    <div class="footer-bar">
        <div id="dateTimeDisplay" class="seven-segment"></div>
        <div id="countdownDisplay" class="seven-segment">00:60</div>
    </div>

    <textarea id="activityInput" rows="4" placeholder="Describe your mood... (editable after recording)" aria-label="Mood description"></textarea>

    <div class="button-group">
        <button class="button" id="startVoice" aria-label="Start voice recording">Start Voice</button>
        <button class="button" id="clear" aria-label="Clear input and image">Clear</button>
        <select id="styleSelect" aria-label="Choose art style">
            <option value="none" selected disabled>Choose Style</option>
            <option value="photo">Hyper-realistic Photo</option>
            <option value="anime">Japanese Anime Style</option>
            <option value="abstract">Abstract</option>
            <option value="surrealism">Surrealism</option>
            <option value="post-modern">Post-modern</option>
            <option value="cyberpunk">Cyberpunk</option>
            <option value="arabic-calligraphy">Arabic Calligraphy</option>
            <option value="chinese-calligraphy">Chinese Calligraphy</option>
            <option value="japanese-calligraphy">Japanese Calligraphy</option>
            <option value="marvel">Marvel Comic</option>
            <option value="art-deco">Art Deco</option>
            <option value="impressionist">Impressionist</option>
            <option value="pop-art">Pop Art</option>
            <option value="digital-painting">Digital Painting</option>
            <option value="minimalism">Minimalism</option>
        </select>
        <button class="button" id="generate" aria-label="Generate image">Generate Image</button>
        <button class="button" id="saveMood" aria-label="Save mood">Save</button>
        <button class="button" id="synthCalmHome" onclick="window.location.href='https://synthcalm.com'" aria-label="Go to SynthCalm Home">SynthCalm Home</button>
    </div>

    <hr style="border: none; border-top: 1px solid #0ff; margin: 20px 0;" />
    <p style="color:#0ff;font-size:14px;text-align:center;">Mood History</p>

    <div class="image-frame">
        <img id="generatedImage" style="display:none; max-width:100%;" alt="Generated Image" />
    </div>

    <div id="moodHistory" style="min-height: 100px;"></div>
    <div id="thinking" style="display:none;text-align:center;color:#ff0;font-family:'Courier New', monospace;">Generating...</div>
</div>

<script>
    // === Clock Display ===
    function updateDateTime() {
        const now = new Date();
        const formatted = now.toLocaleString(undefined, {
            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            hour12: false
        });
        document.getElementById('dateTimeDisplay').textContent = formatted;
    }
    setInterval(updateDateTime, 1000);
    updateDateTime();

    // === Waveform Visualization and Voice Recording ===
    const canvas = document.getElementById("waveform");
    const ctx = canvas.getContext("2d");
    canvas.width = canvas.offsetWidth;
    canvas.height = 160;

    let analyser, dataArray, audioCtx, source, micStream;
    let recognition;
    const startBtn = document.getElementById("startVoice");
    const countdownDisplay = document.getElementById("countdownDisplay");
    let isRecording = false;
    let countdownInterval;

    function drawWaveform() {
        if (!analyser) {
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }
        requestAnimationFrame(drawWaveform);
        analyser.getByteTimeDomainData(dataArray);
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Grid Lines (Yellow)
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 0.5;

        // Vertical Grid Lines
        for (let i = canvas.width / 10; i < canvas.width; i += canvas.width / 10) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, canvas.height);
            ctx.stroke();
        }

        // Horizontal Grid Lines
        for (let i = canvas.height / 4; i < canvas.height; i += canvas.height / 4) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(canvas.width, i);
            ctx.stroke();
        }

        // Draw Waveform (Yellow)
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 2;
        ctx.beginPath();
        const sliceWidth = canvas.width / dataArray.length;
        let x = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const v = dataArray[i] / 128.0;
            const y = (v * canvas.height) / 2;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            x += sliceWidth;
        }
        ctx.lineTo(canvas.width, canvas.height / 2);
        ctx.stroke();
    }
    drawWaveform();

    async function startRecording() {
        if (isRecording) {
            stopRecording();
            return;
        }

        try {
            micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            source = audioCtx.createMediaStreamSource(micStream);
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            dataArray = new Uint8Array(analyser.fftSize);
            source.connect(analyser);
            drawWaveform();

            recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onresult = (event) => {
                const transcript = Array.from(event.results).map(r => r[0].transcript).join('');
                document.getElementById("activityInput").value = transcript;
            };

            recognition.onerror = (event) => {
                console.error("Speech recognition error:", event.error);
                if (event.error === "not-allowed") {
                    alert("Microphone access for speech recognition denied.");
                }
            };

            recognition.onend = () => {
                if (isRecording) recognition.start();
            };

            recognition.start();

            isRecording = true;
            startBtn.classList.add("recording");
            startBtn.textContent = "Stop Voice";
            startCountdown();

        } catch (err) {
            console.error("Recording failed:", err);
            alert("Failed to start recording: " + err.message);
            stopRecording();
        }
    }

    function stopRecording() {
        if (recognition) recognition.stop();
        if (micStream) micStream.getTracks().forEach(track => track.stop());
        if (audioCtx) audioCtx.close();
        analyser = null;
        isRecording = false;
        startBtn.classList.remove("recording");
        startBtn.textContent = "Start Voice";
        clearInterval(countdownInterval);
        countdownDisplay.textContent = "00:60";
    }

    function startCountdown() {
        let seconds = 60;
        countdownDisplay.textContent = `00:${seconds}`;
        countdownInterval = setInterval(() => {
            seconds--;
            countdownDisplay.textContent = `00:${seconds < 10 ? "0" + seconds : seconds}`;
            if (seconds <= 0) stopRecording();
        }, 1000);
    }

    startBtn.addEventListener("click", startRecording);

    // === Image Generation ===
    document.getElementById("generate").addEventListener("click", async () => {
        const prompt = document.getElementById("activityInput").value;
        const style = document.getElementById("styleSelect").value;

        document.getElementById("thinking").style.display = "block"; // Show "Generating..."

        try {
            const response = await fetch('/generate-image', { // Your server endpoint
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ prompt: prompt, style: style }),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const image = data.image; // Assuming your server returns { image: "base64..." }

            document.getElementById("generatedImage").src = image;
            document.getElementById("generatedImage").style.display = "block";
        } catch (error) {
            console.error("Image generation error:", error);
            alert("Failed to generate image.");
        }

        document.getElementById("thinking").style.display = "none"; // Hide "Generating..."
    });

    // === Save Mood to History ===
    document.getElementById("saveMood").addEventListener("click", () => {
        const mood = document.getElementById("activityInput").value;
        const imageData = document.getElementById("generatedImage").src;

        // Store mood and image data (e.g., in local storage)
        const moodHistory = JSON.parse(localStorage.getItem('moodHistory') || '[]');
        moodHistory.push({ mood, imageData, timestamp: new Date().toISOString() });
        localStorage.setItem('moodHistory', JSON.stringify(moodHistory));

        // Display mood history (e.g., in the moodHistory div)
        displayMoodHistory();
    });

    function displayMoodHistory() {
        const moodHistory = JSON.parse(localStorage.getItem('moodHistory') || '[]');
        const moodHistoryDiv = document.getElementById('moodHistory');
        moodHistoryDiv.innerHTML = ''; // Clear previous history

        moodHistory.forEach(item => {
            const moodEntry = document.createElement('div');
            moodEntry.innerHTML = `<p>${item.timestamp}: ${item.mood}</p><img src="${item.imageData}" style="max-width: 100px;">`;
            moodHistoryDiv.appendChild(moodEntry);
        });
    }

    // Call displayMoodHistory on page load to show existing history
    displayMoodHistory();

    // === Clear Input and Image ===
    document.getElementById("clear").addEventListener("click", () => {
        document.getElementById("activityInput").value = "";
        document.getElementById("generatedImage").style.display = "none";
    });

    document.getElementById("styleSelect").addEventListener("click", () => {
        document.getElementById("styleSelect").classList.add("active");
    });
    document.getElementById("styleSelect").addEventListener("change", () => {
        document.getElementById("styleSelect").classList.remove("active");
    });

    function addButtonActiveFeedback(elementId) {
        const element = document.getElementById(elementId);
        element.classList.add("active");
        setTimeout(() => element.classList.remove("active"), 500);
    }

    document.getElementById("saveMood").addEventListener("click", () => addButtonActiveFeedback("saveMood"));
    document.getElementById("synthCalmHome").addEventListener("click", () => addButtonActiveFeedback("synthCalmHome"));
    document.getElementById("generate").addEventListener("click", () => addButtonActiveFeedback("generate"));

</script>
</body>
</html>
